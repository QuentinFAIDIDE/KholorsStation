syntax = "proto3";
package HeadlessAudioBroadcast;

// The service receiving audio buffers with metadata.
service KholorsHeadlessAudioBroadcast {
    // Upload an audio buffer.
    rpc UploadAudioSegment (AudioSegmentPayload) returns (AudioSegmentUploadResponse) {}
    rpc GetAudioTasks (AudioTasksOffset) returns (AudioTasks) {}
  }
  
  // The request that contains the audio segment to upload as well as the metadata attached to it.
  message AudioSegmentPayload {
    // 64 bits hash of a RFC 4122 version 4 UUID provided by Juce UUID implementation that we randomly assign to VST isntances
    fixed64 track_identifier = 1;
    // Bytes representing a RGBA color as a set of 4 unsigned 8 bits integers that are from left (first) to right (last): RED, GREEN, BLUE, ALPHA.
    // They are representing the color attached to the UUID hash attached.
    fixed32 track_color = 2;
    // Timestamp in millisecond at which the payload was sent
    int64 payload_sent_time_unix_ms = 3;
    // Name of the channel to display on screen.
    string track_name = 4;
    // Sample rate of the daw signal.
    int32 daw_sample_rate = 5;
    // Beats per minute setup in the DAW.
    double daw_bpm = 6;
    // Numerator of the DAW time signature.
    int32 daw_time_signature_numerator = 7;
    // Denominator of the daw time signature.
    int32 daw_time_signature_denominator = 8;
    // Is the daw in loop mode ?
    bool daw_is_looping = 9;
    // Is the daw currently playing ?
    bool daw_is_playing = 10;
    // Is this DAW providing the basic informations required to run this VST ?
    bool daw_not_supported = 11;
    // Start of loop section for this daw, in fractions of quarter-notes.
    double daw_loop_start = 12;
    // End of loop section for this daw, in fractions of quarter-notes.
    double daw_loop_end = 13;
    // Sample time at the start of the segment
    int64 segment_start_sample = 14;
    // Duration of the segment in samples
    uint64 segment_sample_duration = 15;
    // Number of audio channels for this signal.
    int32 segment_no_channels = 16;
    // Audio content of the segment, arranged as a sequence of floats.
    // There are segment_no_channels segments of length segment_sample_duration.
    // It can also be empty, meaning this channel segment has so little intensity it can be ignored.
    repeated float segment_audio_samples = 17; 
  }

  message AudioTasksOffset {
    // the offset of incrementally numbered audio tasks
    // that was last returned by the audio server.
    uint64 task_offset = 1;
    // this one will ensure that if a task offset
    // is received and was for a server that was previously
    // closed, it will not be considered and the offset
    // will be treated as zero.
    uint64 server_identifier = 2;
  }

  message FftToDrawTask {
    // beats per minute of the daw
    double daw_bpm = 1;
    // Numerator of the DAW time signature.
    int32 daw_time_signature_numerator = 2;
    // Denominator of the daw time signature.
    int32 daw_time_signature_denominator = 3;
    // 64 bits hash of a RFC 4122 version 4 UUID provided by Juce UUID implementation that we randomly assign to VST isntances
    fixed64 track_identifier = 4;
    // Name of the channel to display on screen.
    string track_name = 5;
    // Bytes representing a RGBA color as a set of 4 unsigned 8 bits integers that are from left (first) to right (last): RED, GREEN, BLUE, ALPHA.
    // They are representing the color attached to the UUID hash attached.
    fixed32 track_color = 6;
    // number of channels on the track
    uint32 total_no_channels = 7;
    // Index of this specific channel data
    uint32 channel_index = 8;
    // sample rate
    uint32 sample_rate = 9;
    // audio sample on which this audio segment starts
    uint32 segment_start_sample = 10;
    // length of the audio segment
    uint64 segment_sample_length = 11;
    // time at which the segment was sent
    int64 sent_time_unix_ms = 12;
    // number of ffts included in the data
    uint32 no_ffts = 13;
    // actual fft data
    repeated float fft_data = 14;
  }

  // List of audio update tasks that happens after the offset
  // given in the request.
  message AudioTasks {
    uint64 new_offset = 1;
    uint64 server_identifier = 2;
    repeated FftToDrawTask fft_to_draw_tasks = 6;
  }

  // The reply to an audio buffer and metadata upload request.
  message AudioSegmentUploadResponse {
  }
  